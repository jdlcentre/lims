#!/usr/bin/python
import os
import re
import string
import sys
from postgres import Postgres
from pprint import pprint
# TODO: Notes:
TODO = """
    https://docs.jboss.org/hibernate/orm/4.1/manual/en-US/html/ch05.html
        This should be added to the date field and possibly some others: @Column(updatable=false). @Immutable might be another way to do this
        It is strongly recommended that you use version/timestamp columns for optimistic locking with Hibernate. This strategy optimizes performance and correctly handles modifications made to detached instances (i.e. when Session.merge() is used).
        
        Search for 5.1.3 Optimistic locking properties
"""

script_path = os.path.dirname(os.path.realpath(__file__))
reg = re.compile('y$')

class Column:
    def __init__(self, name, java_data_type, character_maximum_length, is_nullable, is_pk, referenced_table):
        self.name = name
        self.java_name = java_name(name, True)
        self.java_name_lc = java_name(name, False)

        self.java_data_type = java_data_type
        self.character_maximum_length = character_maximum_length
        self.is_nullable = is_nullable
        self.is_pk = is_pk
        self.is_fk = referenced_table != None
        if self.is_fk:
            self.referenced_table = referenced_table
            self.referenced_table_java_name = java_name(referenced_table, True)
            self.referenced_table_java_name_lc = java_name(referenced_table, False)

    def __str__(self):
        return "Column: {0} {1}, max len: {2}, PK: {3}, Ref: {4}".format(self.java_data_type, self.java_name_lc, self.character_maximum_length, self.is_pk, self.referenced_table)

class Table:
    def __init__(self, name, columns, referencing_table_names):
        self.name = name
        self.is_mm = name[-3:] == '_mm'
        self.java_name = java_name(name, True)
        self.java_name_lc = java_name(name, False)
        self.columns = columns
        self.referencing_table_names = []

        for referencing_table_name in referencing_table_names:
            # WARNING: This is hacky!
            original_referencing_table_name = referencing_table_name
            if referencing_table_name[-3:] == '_mm':
                referencing_table_name = string.replace(referencing_table_name[:-2], name + '_', '')[:-1]

            self.referencing_table_names.append(
            (
                java_name(referencing_table_name, True),
                pluralise(java_name(referencing_table_name, True)),
                pluralise(java_name(referencing_table_name, False)),
                original_referencing_table_name
            ))
    
    def __str__(self):
        output = self.java_name
        
        for column in columns:
            output += "\n    " + str(column)
            
        return output

def java_name(name, cap_first):
    name_java = ''
    capitalise = cap_first

    for letter in name:
        if letter == '_':
            capitalise = True
            continue

        if capitalise:
            letter = chr(ord(letter) - 32)

        name_java += letter
        capitalise = False
    
    return name_java

def pluralise(name):
    if name == 'person':
        return 'people'
    
    if name == 'Person':
        return 'People'
    
    if reg.search(name):
        return reg.sub('ies', name)
    
    else:
        return name + "s"
    
type_map = {
    'character varying': 'String',
    'character': 'String',
    'integer' : 'int',
    'boolean' : 'boolean',
    'timestamp without time zone' : 'Date',
    'USER-DEFINED': 'Geometry',
    'bit': 'int',
    'double precision': 'double'
}

class JavaContent(object):
    header_text = """/*
 * Copyright Curtin University, 2015.
 */
// DO NOT MODIFY THIS FILE BY HAND. IT WAS GENERATED BY generate_orm_files.py
"""
    def __init__(self, package, dependencies, table):
        self.package = package
        self.table = table
        self.dependencies = dependencies

    def __str__(self):
        output = self.header_text + "package " + self.package + ";\n\n"
        
        for dependency in self.dependencies:
            output += "import " + dependency + ";\n"
        
        return output

class JavaDomainFile(JavaContent):
    def __init__(self, table):
        dependencies = [
            "java.util.Date",
            "java.util.HashSet",
            "java.util.List",
            "java.util.Set",
            "javax.persistence.CascadeType",
            "javax.persistence.Column",
            "javax.persistence.Entity",
            "javax.persistence.FetchType",
            "javax.persistence.GeneratedValue",
            "javax.persistence.GenerationType",
            "javax.persistence.Id",
            "javax.persistence.JoinColumn",
            "javax.persistence.JoinTable",
            "javax.persistence.ManyToMany",
            "javax.persistence.ManyToOne",
            "javax.persistence.OneToMany",
            "javax.persistence.OrderBy",
            "javax.persistence.SequenceGenerator",
            "javax.persistence.Table",
            "javax.persistence.Temporal",
            "javax.persistence.TemporalType",
            "org.hibernate.annotations.Type",
            "com.vividsolutions.jts.geom.Geometry"
        ]

        super(JavaDomainFile, self).__init__(
            "au.edu.curtin.lims.domain",
            dependencies,
            table)

    def __str__(self):
        output = super(JavaDomainFile, self).__str__() + """
@Entity
@Table(name = "{0}")
@SequenceGenerator(name = "{0}_{0}_id_seq", sequenceName = "{0}_{0}_id_seq", allocationSize = 1)
public class {1} implements Comparable<{1}> {{""".format(self.table.name, self.table.java_name)

        # Print private fields:
        for column in self.table.columns:
            length_str = ''
            
            if column.is_fk:
                output += """
    private {0} {1};
""".format( column.referenced_table_java_name,
            column.referenced_table_java_name_lc)
                
            else:
                output += """
    private {0} {1};
""".format( column.java_data_type,
            column.java_name_lc)

        # Print private set fields:
        for ref in table.referencing_table_names:
            referencing_table_name_java = ref[0]
            referencing_table_plural_lc = ref[2]
            original_referencing_table_name = ref[3]
            
            if original_referencing_table_name[-3:] != '_mm':
                output += """
    private List<{0}> {1};
""".format( referencing_table_name_java,
            referencing_table_plural_lc)
            
            else:
                output += """
    private Set<{0}> {1} = new HashSet<{0}>();
""".format( referencing_table_name_java,
                referencing_table_plural_lc)
            
        # Print empty public constructor:
        output += """
    public {0}() {{ }}
""".format(table.java_name)            

        # Print getters and setters:
        for column in self.table.columns:
            setter_access = "public"
            
            if column.java_data_type == 'String':
                length_str = ", length = {0}".format(column.character_maximum_length)
            
            if column.is_fk:
                output += """
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "{0}")
    public {1} get{1}() {{
        return {2};
    }}
    
    public void set{1}({1} {2}) {{
        this.{2} = {2};
    }}
""".format(column.name, column.referenced_table_java_name, column.referenced_table_java_name_lc)

            else:
                if column.is_pk:
                    setter_access = "private"
                    column.java_data_type = "Integer"
                    output += """
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "{0}_{0}_id_seq")""".format(table_name)
                    column.java_data_type = "Integer"
            
                elif column.java_data_type == 'Date':
                    output += """
    @Temporal(TemporalType.TIMESTAMP)"""
    
                elif column.java_data_type == 'Geometry':
                    output += """
    @Type(type = "org.hibernate.spatial.GeometryType")"""

                output += """
    @Column(name = "{0}", nullable = {1}{2})""".format(
                column.name,
                column.is_nullable,
                length_str)
            
                output += """
    public {0} get{1}() {{
        return this.{2};
    }}
    
    {4}{3} void set{1}({0} {2}) {{
        this.{2} = {2};
    }}
""".format(column.java_data_type, column.java_name, column.java_name_lc, setter_access, "@SuppressWarnings(\"unused\")\n    " if setter_access == 'private' else "") # TODO: remove this supperss BS and ref {4}

        # Print getters and setters for sets:
        for ref in table.referencing_table_names:
            referencing_table_name_java = ref[0]
            referencing_table_plural = ref[1]
            referencing_table_plural_lc = ref[2]
            original_referencing_table_name = ref[3]

            collection_type = "Set"
            
            if original_referencing_table_name[-3:] != '_mm':
                output += """
    @OneToMany(
        mappedBy = "{0}",
        fetch = FetchType.LAZY)
    @OrderBy("{1}_id")""".format(
                table.java_name_lc,
                original_referencing_table_name)
                collection_type = "List"
            else:
                # If this the first table in the lookup table's name:
                if original_referencing_table_name[:len(table.name)] == table.name:
                    output += """
    @ManyToMany(
            fetch = FetchType.LAZY,
            cascade = {{ CascadeType.PERSIST, CascadeType.MERGE }})
    @JoinTable(
        name = "{0}",
        joinColumns = {{ @JoinColumn(name = "{1}_id") }},
        inverseJoinColumns = {{ @JoinColumn(name = "{2}") }})""".format(
                    original_referencing_table_name,
                    table.name,
                    original_referencing_table_name[len(table.name) + 1:-3] + "_id")

                else:
                    output += """
    @ManyToMany(
            mappedBy = "{0}",
            fetch = FetchType.LAZY,
            cascade = {{ CascadeType.PERSIST, CascadeType.MERGE }})""".format(
                    pluralise(table.java_name_lc))

            output += """
    public {4}<{1}> get{2}() {{
        return this.{3};
    }}
    
    public void set{2}({4}<{1}> {3}) {{
        this.{3} = {3};
    }}
""".format(
            table.java_name_lc,
            referencing_table_name_java,
            referencing_table_plural,
            referencing_table_plural_lc,
            collection_type)

	output += """
    @Override
    public int compareTo({0} o) {{
        return this.get{0}Id().compareTo(o.get{0}Id());
    }}
""".format(table.java_name)

        output += "}"
        return output

class JavaDBFile(JavaContent):
    def __init__(self, table):
        super(JavaDBFile, self).__init__(
            "au.edu.curtin.lims.db",
            [ "au.edu.curtin.lims.domain." + table.java_name ],
            table)

    def __str__(self):
        output = super(JavaDBFile, self).__str__() + """
public interface I{0}Repository extends IRepository<{0}> {{

""".format(self.table.java_name)

        output += "}"
        return output

class JavaHibernateFile(JavaContent):
    def __init__(self, table):
        super(JavaHibernateFile, self).__init__(
            "au.edu.curtin.lims.db.hibernate4",
            [ 
                "javax.inject.Inject",
                "org.hibernate.SessionFactory",
                "org.springframework.stereotype.Repository",
                "au.edu.curtin.lims.db.I" + table.java_name + "Repository",
                "au.edu.curtin.lims.domain." + table.java_name
            ],
            table)

    def __str__(self):
        output = super(JavaHibernateFile, self).__str__() + """
@Repository
public class Hibernate{0}Repository extends BaseHibernateRepository<{0}> implements I{0}Repository {{
    @Inject
    public Hibernate{0}Repository(SessionFactory sessionFactory) {{
        super({0}.class, sessionFactory);
    }}

    public {0} save({0} {1}) {{
        this.currentSession().save({1});
        return {1};
//        return new {0}(
//            (Integer) id""".format(self.table.java_name, self.table.java_name_lc)
            
        for column in self.table.columns:
            if column.is_pk:
                continue
            
            output += """,
//            {0}.get{1}()""".format(table.java_name_lc, column.java_name)

        output += """\n//);
    }
}"""
        return output

# The contents of db_string.txt should be: postgres://curtin_lims_user:password@localhost/curtin_lims
db_string = ''
with open(script_path + '/db_string.txt') as f:
    db_string = f.readlines()[0]

db = Postgres(db_string)

tables = []
table_names = db.all("SELECT table_name FROM INFORMATION_SCHEMA.Tables WHERE table_schema = 'public' AND table_type = 'BASE TABLE' AND table_name NOT IN ('spatial_ref_sys', 'gt_pk_metadata_table')")
reference_descriptions = db.all("""
SELECT
    kcu.table_name as referencing_table,
    ccu.table_name as referenced_table,
    kcu.column_name
FROM
    information_schema.table_constraints AS tc
    JOIN information_schema.key_column_usage AS kcu
      ON tc.constraint_name = kcu.constraint_name
    JOIN information_schema.constraint_column_usage AS ccu
      ON ccu.constraint_name = tc.constraint_name
WHERE 	constraint_type = 'FOREIGN KEY'
AND	tc.table_catalog = 'curtin_lims'""")

for table_name in table_names:
    columns = []
    column_descriptions = db.all('SELECT column_name, data_type, character_maximum_length, is_nullable FROM INFORMATION_SCHEMA.COLUMNS WHERE table_name = %(table_name)s ORDER BY ordinal_position', {'table_name': table_name})
    
    referencing_table_names = []
    for column_description in column_descriptions:
        referenced_table = None
        for reference_description in reference_descriptions:
            if reference_description.referencing_table == table_name and reference_description.column_name == column_description.column_name:
                referenced_table = reference_description.referenced_table
            elif reference_description.referenced_table == table_name and reference_description.column_name == column_description.column_name:
                referencing_table_names.append(reference_description.referencing_table)
        
        column = Column(
            column_description.column_name,
            type_map[column_description.data_type],
            column_description.character_maximum_length,
            "true" if column_description.is_nullable == 'YES' else "false",
            column_description.column_name == table_name + '_id',
            referenced_table)

        columns.append(column)

    table = Table(table_name, columns, referencing_table_names)
    tables.append(table)
    
    if not table.is_mm:
        java_domain_file = JavaDomainFile(table)
        java_db_file = JavaDBFile(table)
        java_hibernate_file = JavaHibernateFile(table)
        
        with open(script_path + '/../src/main/java/au/edu/curtin/lims/domain/{0}.java'.format(table.java_name), 'w') as output_file:
           output_file.write(str(java_domain_file))

        with open(script_path + '/../src/main/java/au/edu/curtin/lims/db/I{0}Repository.java'.format(table.java_name), 'w') as output_file:
           output_file.write(str(java_db_file))
        
        with open(script_path + '/../src/main/java/au/edu/curtin/lims/db/hibernate4/Hibernate{0}Repository.java'.format(table.java_name), 'w') as output_file:
           output_file.write(str(java_hibernate_file))
